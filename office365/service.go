package office365

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/url"
	"time"
)

// RequestFormats are the time.Format vars we must follow when providing
// datetime params to an API endpoint.
var (
	RequestDateFormat          = "2006-01-02"
	RequestDatetimeFormat      = "2006-01-02T15:04"
	RequestDatetimeLargeFormat = "2006-01-02T15:04:05"

	CreatedDatetimeFormat = "2006-01-02T15:04:05.999Z"
)

// error definition.
var (
	ErrContentTypeRequired = errors.New("ContentType queryParam is required")
	ErrIntervalMismatch    = errors.New("StartTime and EndTime must both be provided or not at all")
	ErrIntervalNegative    = errors.New("interval given is 0 or negative")
	ErrIntervalDay         = errors.New("interval given is more than 24 hours")
	ErrIntervalWeek        = errors.New("StartTime given is more than 7 days in the past")
)

// helpers.
var (
	intervalOneDay = time.Minute * 1440
)

// service holds a pointer to the Client for service related
// methods to access Client methods, such as newRequest and do.
type service struct {
	client *Client
}

// Resource .
type Resource struct {
	Request  ResourceRequest
	Response ResourceResponse
	Errors   []error
}

// AddError .
func (r *Resource) AddError(err error) {
	r.Errors = append(r.Errors, err)
}

// SetRequest .
func (r *Resource) SetRequest(ct *ContentType, startTime time.Time, endTime time.Time) {
	r.Request = ResourceRequest{
		ContentType: ct,
		StartTime:   startTime,
		EndTime:     endTime,
	}
}

// SetResponse .
func (r *Resource) SetResponse(records []AuditRecord) {
	r.Response = ResourceResponse{records}
}

// ResourceRequest .
type ResourceRequest struct {
	ContentType *ContentType
	StartTime   time.Time
	EndTime     time.Time
}

// ResourceResponse .
type ResourceResponse struct {
	Records []AuditRecord
}

// ResourceHandler is an interface for handling streamed resources.
type ResourceHandler interface {
	Handle(<-chan Resource)
}

// Printer implements the ResourceHandler interface.
// It prints a human readable formatted resource on the
// provided writer.
type Printer struct {
	writer io.Writer
}

// NewPrinter returns a printer using the provided writer.
func NewPrinter(w io.Writer) *Printer {
	return &Printer{w}
}

// Handle .
func (h Printer) Handle(in <-chan Resource) {
	for r := range in {
		for idx, e := range r.Errors {
			fmt.Fprintf(h.writer, "[%s] Error%d: %s", r.Request.ContentType, idx, e.Error())
		}
		for _, a := range r.Response.Records {
			auditStr, err := json.Marshal(a)
			if err != nil {
				fmt.Fprintf(h.writer, "error marshalling audit: %s\n", err)
				continue
			}
			var out bytes.Buffer
			json.Indent(&out, auditStr, "", "\t")
			fmt.Fprintf(h.writer, "[%s]\n%s\n", r.Request.ContentType, out.String())
		}
	}
}

// QueryParams .
type QueryParams struct {
	url.Values
}

// NewQueryParams .
func NewQueryParams() *QueryParams {
	return &QueryParams{make(url.Values)}
}

// AddPubIdentifier .
func (p *QueryParams) AddPubIdentifier(pubIdentifier string) {
	if pubIdentifier != "" {
		p.Add("PublisherIdentifier", pubIdentifier)
	}
}

// AddContentType .
func (p *QueryParams) AddContentType(ct *ContentType) error {
	if &ct == nil {
		return ErrContentTypeRequired
	}
	p.Add("contentType", ct.String())
	return nil
}

// AddStartEndTime .
func (p *QueryParams) AddStartEndTime(startTime time.Time, endTime time.Time) error {
	oneOrMoreDatetime := !startTime.IsZero() || !endTime.IsZero()
	bothDatetime := !startTime.IsZero() && !endTime.IsZero()
	if oneOrMoreDatetime && !bothDatetime {
		return ErrIntervalMismatch
	}
	if bothDatetime {
		interval := endTime.Sub(startTime)
		if interval <= 0 {
			return ErrIntervalNegative
		}
		if interval > intervalOneDay {
			return ErrIntervalDay
		}
		if startTime.Before(time.Now().Add(-(intervalOneDay * 7))) {
			return ErrIntervalWeek
		}
		p.Add("startTime", startTime.Format(RequestDatetimeFormat))
		p.Add("endTime", endTime.Format(RequestDatetimeFormat))
	}
	return nil
}

// Subscription represents a response.
type Subscription struct {
	ContentType string  `json:"contentType"`
	Status      string  `json:"status"`
	Webhook     Webhook `json:"webhook"`
}

// Webhook represents both a response and a request payload.
type Webhook struct {
	Status     string `json:"status,omitempty"`
	Address    string `json:"address"`
	AuthID     string `json:"authId,omitempty"`
	Expiration string `json:"expiration,omitempty"`
}

// ContentType represents a type and source of aggregated actions and events
// generated by the Microsoft Office 365 Management Activity API.
type ContentType int

// ContentType enum.
const (
	AuditAzureActiveDirectory ContentType = iota
	AuditExchange
	AuditSharePoint
	AuditGeneral
	DLPAll
)

var contentTypeLiterals = []string{
	"Audit.AzureActiveDirectory",
	"Audit.Exchange",
	"Audit.SharePoint",
	"Audit.General",
	"DLP.All",
}

func (c ContentType) String() string {
	return contentTypeLiterals[c]
}

// GetContentType returns the ContentType represented
// by the provided string literal.
func GetContentType(s string) (*ContentType, error) {
	for idx, v := range contentTypeLiterals {
		if v == s {
			ct := ContentType(idx)
			return &ct, nil
		}
	}
	return nil, fmt.Errorf("ContentType invalid")
}

// ContentTypeValid validates that a string is a valid ContentType.
func ContentTypeValid(s string) bool {
	if _, err := GetContentType(s); err != nil {
		return false
	}
	return true
}

// Content represents metadata needed for retreiving aggregated data.
type Content struct {
	ContentType       string `json:"contentType"`
	ContentID         string `json:"contentId"`
	ContentURI        string `json:"contentUri"`
	ContentCreated    string `json:"contentCreated"`
	ContentExpiration string `json:"contentExpiration"`
}

// AuditRecord represents an event or action returned by Audit endpoint.
type AuditRecord struct {
	ID             string             `json:"Id"`
	RecordType     AuditLogRecordType `json:"RecordType"`
	CreationTime   string             `json:"CreationTime"`
	Operation      string             `json:"Operation"`
	OrganizationID string             `json:"OrganizationId"`
	UserType       UserType           `json:"UserType"`
	UserKey        string             `json:"UserKey"`
	Workload       string             `json:"Workload,omitempty"`
	ResultStatus   string             `json:"ResultStatus,omitempty"`
	ObjectID       string             `json:"ObjectId,omitempty"`
	UserID         string             `json:"UserId"`
	ClientIP       string             `json:"ClientIP"`
	Scope          AuditLogScope      `json:"Scope,omitempty"`
}

// AuditLogRecordType identifies the type of AuditRecord.
// https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-schema#enum-auditlogrecordtype---type-edmint32
type AuditLogRecordType int

// AuditLogRecordType enum.
const (
	ExchangeAdmin AuditLogRecordType = iota + 1
	ExchangeItem
	ExchangeItemGroup
	SharePoint
	SharePointFileOperation
	AzureActiveDirectory
	AzureActiveDirectoryAccountLogon
	DataCenterSecurityCmdlet
	ComplianceDLPSharePoint
	Sway
	ComplianceDLPExchange
	SharePointSharingOperation
	AzureActiveDirectoryStsLogon
	SecurityComplianceCenterEOPCmdlet
	PowerBIAudit
	CRM
	Yammer
	SkypeForBusinessCmdlets
	Discovery
	MicrosoftTeams
	ThreatIntelligence
	MailSubmission
	MicrosoftFlow
	AeD
	MicrosoftStream
	ComplianceDLPSharePointClassification
	Project
	SharePointListOperation
	DataGovernance
	SecurityComplianceAlerts
	ThreatIntelligenceURL
	SecurityComplianceInsights
	WorkplaceAnalytics
	PowerAppsApp
	ThreatIntelligenceAtpContent
	TeamsHealthcare
	DataInsightsRestAPIAudit
	SharePointListItemOperation
	SharePointContentTypeOperation
	SharePointFieldOperation
	AirInvestigation
	Quarantine
	MicrosoftForms
)

var auditLogRecordTypeLiterals = []string{
	"ExchangeAdmin",
	"ExchangeItem",
	"ExchangeItemGroup",
	"SharePoint",
	"SharePointFileOperation",
	"AzureActiveDirectory",
	"AzureActiveDirectoryAccountLogon",
	"DataCenterSecurityCmdlet",
	"ComplianceDLPSharePoint",
	"Sway",
	"ComplianceDLPExchange",
	"SharePointSharingOperation",
	"AzureActiveDirectoryStsLogon",
	"SecurityComplianceCenterEOPCmdlet",
	"PowerBIAudit",
	"CRM",
	"Yammer",
	"SkypeForBusinessCmdlets",
	"Discovery",
	"MicrosoftTeams",
	"ThreatIntelligence",
	"MailSubmission",
	"MicrosoftFlow",
	"AeD",
	"MicrosoftStream",
	"ComplianceDLPSharePointClassification",
	"Project",
	"SharePointListOperation",
	"DataGovernance",
	"SecurityComplianceAlerts",
	"ThreatIntelligenceUrl",
	"SecurityComplianceInsights",
	"WorkplaceAnalytics",
	"PowerAppsApp",
	"ThreatIntelligenceAtpContent",
	"TeamsHealthcare",
	"DataInsightsRestApiAudit",
	"SharePointListItemOperation",
	"SharePointContentTypeOperation",
	"SharePointFieldOperation",
	"AirInvestigation",
	"Quarantine",
	"MicrosoftForms",
}

func (a AuditLogRecordType) String() string {
	return auditLogRecordTypeLiterals[a]
}

// UserType identifies the type of user in AuditRecord.
// https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-schema#enum-user-type---type-edmint32
type UserType int

// UserType enum.
const (
	Regular UserType = iota
	Reserved
	Admin
	DcAdmin
	System
	Application
	ServicePrincipal
	CustomPolicy
	SystemPolicy
)

var userTypeLiterals = []string{
	"Regular",
	"Reserved",
	"Admin",
	"DcAdmin",
	"System",
	"Application",
	"ServicePrincipal",
	"CustomPolicy",
	"SystemPolicy",
}

func (u UserType) String() string {
	return userTypeLiterals[u]
}

// AuditLogScope identifies the scope of an AuditRecord.
// https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-schema#auditlogscope
type AuditLogScope int

// AuditLogScope enum.
const (
	Online AuditLogScope = iota
	Onprem
)

var auditLogScopeLiterals = []string{
	"Online",
	"Onprem",
}

func (a AuditLogScope) String() string {
	return auditLogScopeLiterals[a]
}
